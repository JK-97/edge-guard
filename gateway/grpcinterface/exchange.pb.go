// Code generated by protoc-gen-go. DO NOT EDIT.
// source: exchange.proto

package trueno

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Block struct {
	Index                uint64   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Hash                 string   `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	Block                []byte   `protobuf:"bytes,3,opt,name=block,proto3" json:"block,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Block) Reset()         { *m = Block{} }
func (m *Block) String() string { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()    {}
func (*Block) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0328a4f16f87ea1, []int{0}
}

func (m *Block) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Block.Unmarshal(m, b)
}
func (m *Block) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Block.Marshal(b, m, deterministic)
}
func (m *Block) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block.Merge(m, src)
}
func (m *Block) XXX_Size() int {
	return xxx_messageInfo_Block.Size(m)
}
func (m *Block) XXX_DiscardUnknown() {
	xxx_messageInfo_Block.DiscardUnknown(m)
}

var xxx_messageInfo_Block proto.InternalMessageInfo

func (m *Block) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Block) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Block) GetBlock() []byte {
	if m != nil {
		return m.Block
	}
	return nil
}

type BinData struct {
	Uuid                 string   `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Hash                 string   `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	Size                 uint64   `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
	Pack                 *Block   `protobuf:"bytes,4,opt,name=pack,proto3" json:"pack,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinData) Reset()         { *m = BinData{} }
func (m *BinData) String() string { return proto.CompactTextString(m) }
func (*BinData) ProtoMessage()    {}
func (*BinData) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0328a4f16f87ea1, []int{1}
}

func (m *BinData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BinData.Unmarshal(m, b)
}
func (m *BinData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BinData.Marshal(b, m, deterministic)
}
func (m *BinData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinData.Merge(m, src)
}
func (m *BinData) XXX_Size() int {
	return xxx_messageInfo_BinData.Size(m)
}
func (m *BinData) XXX_DiscardUnknown() {
	xxx_messageInfo_BinData.DiscardUnknown(m)
}

var xxx_messageInfo_BinData proto.InternalMessageInfo

func (m *BinData) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *BinData) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *BinData) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *BinData) GetPack() *Block {
	if m != nil {
		return m.Pack
	}
	return nil
}

func init() {
	proto.RegisterType((*Block)(nil), "trueno.Block")
	proto.RegisterType((*BinData)(nil), "trueno.BinData")
}

func init() { proto.RegisterFile("exchange.proto", fileDescriptor_e0328a4f16f87ea1) }

var fileDescriptor_e0328a4f16f87ea1 = []byte{
	// 219 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x50, 0x4d, 0x4b, 0xc4, 0x30,
	0x10, 0x35, 0x9a, 0x5d, 0xed, 0xac, 0x1f, 0x30, 0x78, 0x08, 0x9e, 0x62, 0x4f, 0x39, 0x15, 0xd9,
	0xc5, 0x3f, 0x50, 0x56, 0xbc, 0x07, 0xfc, 0x01, 0x69, 0x1b, 0x4c, 0x68, 0x49, 0x4a, 0x3f, 0xb4,
	0xf8, 0xeb, 0xa5, 0x13, 0xf1, 0x20, 0x5e, 0xf6, 0xf6, 0xde, 0xcc, 0x7b, 0x8f, 0x37, 0x03, 0xb7,
	0x76, 0xa9, 0x9d, 0x09, 0xef, 0xb6, 0xe8, 0x87, 0x38, 0x45, 0xdc, 0x4e, 0xc3, 0x6c, 0x43, 0xcc,
	0x5f, 0x61, 0x53, 0x76, 0xb1, 0x6e, 0xf1, 0x1e, 0x36, 0x3e, 0x34, 0x76, 0x11, 0x4c, 0x32, 0xc5,
	0x75, 0x22, 0x88, 0xc0, 0x9d, 0x19, 0x9d, 0x38, 0x97, 0x4c, 0x65, 0x9a, 0xf0, 0xaa, 0xac, 0x56,
	0x8b, 0xb8, 0x90, 0x4c, 0x5d, 0xeb, 0x44, 0x72, 0x07, 0x97, 0xa5, 0x0f, 0x47, 0x33, 0x99, 0xd5,
	0x34, 0xcf, 0xbe, 0xa1, 0xa4, 0x4c, 0x13, 0xfe, 0x37, 0x08, 0x81, 0x8f, 0xfe, 0xcb, 0x52, 0x0e,
	0xd7, 0x84, 0xf1, 0x11, 0x78, 0x6f, 0xea, 0x56, 0x70, 0xc9, 0xd4, 0x6e, 0x7f, 0x53, 0xa4, 0x9a,
	0x05, 0x75, 0xd4, 0xb4, 0xda, 0x7f, 0xc0, 0xd5, 0xcb, 0xcf, 0x31, 0xf8, 0x0c, 0xbb, 0x63, 0xfc,
	0x0c, 0x5d, 0x34, 0x4d, 0xe9, 0x03, 0xde, 0xfd, 0xea, 0x53, 0x95, 0x87, 0xbf, 0x83, 0xfc, 0x4c,
	0xb1, 0x27, 0x86, 0x07, 0xc8, 0xde, 0xfa, 0x13, 0x4d, 0xd5, 0x96, 0x3e, 0x77, 0xf8, 0x0e, 0x00,
	0x00, 0xff, 0xff, 0x5d, 0x16, 0xfc, 0xad, 0x4b, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ExchangeClient is the client API for Exchange service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ExchangeClient interface {
	DownloadBin(ctx context.Context, opts ...grpc.CallOption) (Exchange_DownloadBinClient, error)
	UploadBin(ctx context.Context, opts ...grpc.CallOption) (Exchange_UploadBinClient, error)
}

type exchangeClient struct {
	cc *grpc.ClientConn
}

func NewExchangeClient(cc *grpc.ClientConn) ExchangeClient {
	return &exchangeClient{cc}
}

func (c *exchangeClient) DownloadBin(ctx context.Context, opts ...grpc.CallOption) (Exchange_DownloadBinClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Exchange_serviceDesc.Streams[0], "/trueno.Exchange/DownloadBin", opts...)
	if err != nil {
		return nil, err
	}
	x := &exchangeDownloadBinClient{stream}
	return x, nil
}

type Exchange_DownloadBinClient interface {
	Send(*BinData) error
	Recv() (*BinData, error)
	grpc.ClientStream
}

type exchangeDownloadBinClient struct {
	grpc.ClientStream
}

func (x *exchangeDownloadBinClient) Send(m *BinData) error {
	return x.ClientStream.SendMsg(m)
}

func (x *exchangeDownloadBinClient) Recv() (*BinData, error) {
	m := new(BinData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *exchangeClient) UploadBin(ctx context.Context, opts ...grpc.CallOption) (Exchange_UploadBinClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Exchange_serviceDesc.Streams[1], "/trueno.Exchange/UploadBin", opts...)
	if err != nil {
		return nil, err
	}
	x := &exchangeUploadBinClient{stream}
	return x, nil
}

type Exchange_UploadBinClient interface {
	Send(*BinData) error
	Recv() (*BinData, error)
	grpc.ClientStream
}

type exchangeUploadBinClient struct {
	grpc.ClientStream
}

func (x *exchangeUploadBinClient) Send(m *BinData) error {
	return x.ClientStream.SendMsg(m)
}

func (x *exchangeUploadBinClient) Recv() (*BinData, error) {
	m := new(BinData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ExchangeServer is the server API for Exchange service.
type ExchangeServer interface {
	DownloadBin(Exchange_DownloadBinServer) error
	UploadBin(Exchange_UploadBinServer) error
}

// UnimplementedExchangeServer can be embedded to have forward compatible implementations.
type UnimplementedExchangeServer struct {
}

func (*UnimplementedExchangeServer) DownloadBin(srv Exchange_DownloadBinServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadBin not implemented")
}
func (*UnimplementedExchangeServer) UploadBin(srv Exchange_UploadBinServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadBin not implemented")
}

func RegisterExchangeServer(s *grpc.Server, srv ExchangeServer) {
	s.RegisterService(&_Exchange_serviceDesc, srv)
}

func _Exchange_DownloadBin_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ExchangeServer).DownloadBin(&exchangeDownloadBinServer{stream})
}

type Exchange_DownloadBinServer interface {
	Send(*BinData) error
	Recv() (*BinData, error)
	grpc.ServerStream
}

type exchangeDownloadBinServer struct {
	grpc.ServerStream
}

func (x *exchangeDownloadBinServer) Send(m *BinData) error {
	return x.ServerStream.SendMsg(m)
}

func (x *exchangeDownloadBinServer) Recv() (*BinData, error) {
	m := new(BinData)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Exchange_UploadBin_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ExchangeServer).UploadBin(&exchangeUploadBinServer{stream})
}

type Exchange_UploadBinServer interface {
	Send(*BinData) error
	Recv() (*BinData, error)
	grpc.ServerStream
}

type exchangeUploadBinServer struct {
	grpc.ServerStream
}

func (x *exchangeUploadBinServer) Send(m *BinData) error {
	return x.ServerStream.SendMsg(m)
}

func (x *exchangeUploadBinServer) Recv() (*BinData, error) {
	m := new(BinData)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Exchange_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trueno.Exchange",
	HandlerType: (*ExchangeServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DownloadBin",
			Handler:       _Exchange_DownloadBin_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UploadBin",
			Handler:       _Exchange_UploadBin_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "exchange.proto",
}
